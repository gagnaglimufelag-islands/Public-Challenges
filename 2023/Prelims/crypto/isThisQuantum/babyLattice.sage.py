

# This file was *autogenerated* from the file babyLattice.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1024 = Integer(1024); _sage_const_48 = Integer(48); _sage_const_2 = Integer(2); _sage_const_23 = Integer(23); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from Crypto.Util.number import getPrime, bytes_to_long as btl, long_to_bytes as ltb
from hashlib import sha512
from tqdm import trange
from pwn import *
from time import time

if args['NOSPAMPLOX']:
	NOSPAMPLOX = True
else:
	NOSPAMPLOX = False

n = _sage_const_1024 
MSBs = _sage_const_48 
shiftAmt = n - MSBs
k = MSBs - _sage_const_2 
# NOTE: The attacker has an advantage when k \approx sqrt(log_2 p) and d = 2 * sqrt(log_2 p)
# d = 64
d = _sage_const_23 

if args['LOCAL']:
	conn = process('./serverUncensored.py')
else:
	domain = args['DOMAIN']
	port = int(args['PORT'])
	conn = remote(domain, port)

p = int(conn.readline()[_sage_const_3 :])
inputs = []
leaks = []

for x in trange(d):
	x = str(x).encode()
	conn.sendline(x)
	inputs.append(pow(_sage_const_2 , btl(sha512(x).digest()), p))
	leaks.append(int(conn.recvline()[_sage_const_7 :]) << shiftAmt)

conn.close()

print(f'Bits in p: {n}')
print(f'Queries: {d}')
print(f'MSBs: {k+_sage_const_2 }')

def buildBasis(oracleInputs):
	"""Returns a basis using the HNP game parameters and inputs to our oracle
	"""
	basisVectors = []
	for i in range(d):
		pVector = [_sage_const_0 ] * (d+_sage_const_1 )
		pVector[i] = p
		basisVectors.append(pVector)
	basisVectors.append(list(oracleInputs) + [QQ(_sage_const_1 )/QQ(p)])
	return Matrix(QQ, basisVectors)

def approximateClosestVector(basis, v):
	"""Returns an approximate CVP solution using Babai's nearest plane algorithm.
	"""
	BL = basis.LLL()
	G, _ = BL.gram_schmidt()
	_, n = BL.dimensions()
	small = vector(ZZ, v)
	for i in reversed(range(n)):
		c = QQ(small * G[i]) / QQ(G[i] * G[i])
		c = c.round()
		small -= BL[i] * c
	return (v - small).coefficients()

print('Building lattice')
# Build a basis using our oracle inputs
lattice = buildBasis(inputs)

if NOSPAMPLOX:
	print("Solving CVP using lattice with basis: [...]")
else:
	print("Solving CVP using lattice with basis:\n%s\n" % str(lattice))

# The non-lattice vector based on the oracle's answers
u = vector(ZZ, list(leaks) + [_sage_const_0 ])
if NOSPAMPLOX:
	print("Vector of MSB oracle answers: [...]")
else:
	print("Vector of MSB oracle answers:\n%s\n" % str(u))

# Solve an approximate CVP to find a vector v which is likely to reveal alpha.
d = time()
v = approximateClosestVector(lattice, u)
print(f'CVP took {time()-d}s')
if NOSPAMPLOX:
	print("Closest lattice vector: [...]")
else:
	print("Closest lattice vector:\n%s\n" % str(v))

recoveredAlpha = (v[-_sage_const_1 ] * p) % p
print(f'FLAG: {ltb(recoveredAlpha)}')

