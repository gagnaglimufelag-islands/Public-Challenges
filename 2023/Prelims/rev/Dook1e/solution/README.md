# Dook1e

We are given a 64-bit ELF binary that is a simple number guessing game. The game consists of guessing 5 "random" numbers that are in the range *1 - 1000* The catch here is that the game is using *srand()* incorrectly and seeds it with a static value instead of using *time(NULL)* That means that the number sequence generated by the game isn't actually randomized.


## Reversing

When we open the binary up with *Ghidra* we can see that all the action is going on in the `main()` function so we can just start reversing that

```C
undefined8 main(void)

{
  int iVar1;
  undefined8 uVar2;
  char local_58 [60];
  int local_1c;
  FILE *local_18;
  uint local_c;
  
  setbuf(stdin,(char *)0x0);
  setbuf(stdout,(char *)0x0);
  local_c = 1;
  srand(0xa5a55);
  print_ascii();
  puts("I\'m thinking of 5 numbers between 1 and 1000.\n");
  while( true ) {
    if (5 < (int)local_c) {
      if (local_c == 6) {
        puts("\nCongratulations! You guessed all 5 numbers in the correct order\n");
        local_18 = fopen("flag.txt","r");
        if (local_18 == (FILE *)0x0) {
          printf("Error opening file \'flag.txt\'");
          uVar2 = 0xffffffff;
        }
        else {
          __isoc99_fscanf(local_18,&DAT_001022d3,local_58);
          puts(local_58);
          fclose(local_18);
          uVar2 = 0;
        }
      }
      else {
        puts("Sorry, you didn\'t guess all 5 numbers correctly.");
        uVar2 = 0;
      }
      return uVar2;
    }
    printf("Enter your guess for number [ %d ] : ",(ulong)local_c);
    __isoc99_scanf(&DAT_00102236);
    iVar1 = rand();
    if (iVar1 % 1000 + 1 != local_1c) break;
    puts("Correct!");
    local_c = local_c + 1;
  }
  if ((0 < local_1c) && (local_1c < 0x3e9)) {
    puts("Incorrect.");
    return 0;
  }
  puts("Number is out of range!");
  return 0;
}

```

Here we see the whole logic for the game and it seems fine but there is a single line of code that breaks the game `srand(0xa5a55)` This seeds the call to `rand()` which means that this specific seed (0xa5a55) will generate a unique sequence for only that seed. When this seed is used to generate numbers, the sequence of the numbers generated will always be the same upon every new game session. This gives the user the ability to predict the 5 seemingly "random" numbers. Let's create a simple *Python* solve script to get our flag from the remote server.


```python

import yaml
import argparse
from pwn import *
from pathlib import Path



# Load the flag dynamically from the meta file
HERE = Path(__file__).parent
FLAG = yaml.safe_load(open(HERE / "meta.yml"))["flags"]


# For local binary testing
def solve(sh):
    try:
        from ctypes import CDLL
    except ImportError:
        log.Error("Failed To Import CDLL from Ctypes!")
    libc = CDLL("./libc.so.6") # Path to LIBC
    libc.srand(678485)
    correct_nums = [str(libc.rand() % 1000 + 1) for x in range(5)]
    log.success(f"Correct NUMS: {correct_nums}")
    for num in correct_nums:
        sh.sendline(num.encode())
    flag = sh.recvall().split()[-1].decode()
    log.success(flag)
    sh.close()
    assert FLAG in flag, flag


def test(domain, port):
    sh = remote(domain, port)
    solve(sh)



if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)

    parser = argparse.ArgumentParser()
    parser.add_argument("domain", default="127.0.0.1", nargs="?")
    parser.add_argument("port", default=1337, type=int, nargs="?")
    args_argparse = parser.parse_args()

    if args.REMOTE:
        test(args_argparse.domain, args_argparse.port)
    else:
        sh = process("./Dook1e")
        solve(sh)

```
